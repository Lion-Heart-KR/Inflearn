//#include <iostream>
//using namespace std;
//
///// <summary> : 연산자 오버로딩
///// [연산자 vs 함수]
///// - 연산자는 피연산자의 개수와 타입이 고정되어있다.
///// 
///// [연산자 오버로딩]
///// - [연산자 함수]를 정의해야 한다.
///// - 함수도 멤버함수, 전역함수가 존재하는 것처럼 연산자 함수도 두 가지 방식으로 만들 수 있다.
///// 
///// [1] : 멤버 연산자 함수
///// - a op b 형태에서 왼쪽을 기준으로 실행된다.
///// - a가 클래스여야 가능하다. => a를 [기준 피연산자]라고 한다.
///// - 한계 : a가 클래스가 아니면 사용할 수 없다.
///// 
///// [2] : 전역 연산자 함수
///// - a op b 형태라면, a와 b 모두 연산자 함수의 피연산자로 만들어 준다.
///// 
///// [무엇이 더 좋은가?]
///// - 그런거는 없다.
///// - 둘 중 하나의 연산자 함수에서만 가능한 동작들이 있다.
///// - 대입연산자는 전역 연산자 함수로는 구현할 수 없다.
///// 
///// [복사 대입 연산자]
///// 
///// </summary>
///// <returns></returns>
//
//class Position
//{
//public:
//	Position(int x, int y) : _x(x), _y(y) { }
//
//	//형식 : operator [캐스팅할 자료형] { 리턴값 } 
//	//리턴 값은 캐스팅할 자료형과 동일해야한다.
//	operator pair<int, int>()
//	{
//		//return pair<int, int>(_x, _y);
//		return make_pair(_x, _y);
//	}
//
//public:
//	int _x;
//	int _y;
//};
//
//
//int main()
//{
//	Position pos1(3, 4);
//	pair<int, int> pInt = pos1;
//	
//	cout << pInt.first << endl;
//
//	return 0;
//}