#include <iostream>
using namespace std;

/// <summary> : 동적할당
/// ※메모리 구조 복습
/// - 실행할 코드가 저장되는 영역 -> 코드 영역
/// - 전역(global)/정적(static)변수 -> 데이터 영역
/// - 지역변수/매개변수 -> 스택영역
/// 
/// - 지금까지는 [데이터], [스택]영역을 이용해서 프로그램을 만들어왔다.
/// - 새로운 영역 [힙] 에 대해서 알아보자.
/// 
/// 실제 상황)
/// - MMORPG 동접자 1명 ~ 20만명, 몬스터 1마리~500만마리...
/// 
/// 스택 영역
/// - 함수가 끝나면 같이 정리되는 불안정한 메모리
/// - 잠시 매개변수를 전달하거나 하는 용도로 사용
/// 
/// 메모리 영역
/// - 프로그램이 실행되는 도중에는 '무조건' 사용되는 영역
/// 
/// 희망사항
/// - 필요할 때만 사용하고, 필요없으면 반납할 수 있는 메모리 영역
/// - 스택과는 다르게 프로그래머가 생성/소멸시점을 관리할 수 있는 메모리영역
/// - 그게 바로 [힙(heap)]
/// 
/// 동적 할당과 연관된 함수/연산자 : (malloc, free), (new, delete), (new[], delete[])
/// 
/// malloc
/// - 할당할 메모리 크기를 건내준다.
/// - 메모리 할당 후 시작 주소를 가리키는 포인터를 반환해준다.(실패시 NULL)
/// 
/// free
/// - malloc(혹은 calloc, realloc)을 사용하여 메모리를 할당 후 사용이 모두 끝났을 때 할당된 영역을 해제
/// - 힙 관리자가 할당/미할당 여부를 구분해서 관리
/// 
/// void*는 무엇일까?
/// - 일단 포인터이므로, 주소를 담는 변수다.
/// - 근데 void는 무엇? : 아무것도 없다?(X)
/// - 주소를 타고 가면, 어떤 자료형이 있는지 모르겠으니, 프로그래머가 적당히 변환해서 사용해라.
/// 
/// </summary>
/// <returns></returns>

class Monster
{
public:
	int _hp;
	int _x;
	int _y;
};

//데이터 영역에 선언
//가능은 한데, 메모리 낭비임. 항상 최대 상한선에 맞춰서 메모리를 잡아야 함.
//심지어, 몬스터가 더 필요한 경우에는 대처할 수 없다.
//Monster monsters[500 * 10000];

int main()
{
	//스택오버플로우 발생함.
	//Monster monsters[500 * 10000];

	// 유저 영역 (메모장, 게임, 곰플레이어 등 응용프로그램 실행)
	// ---------------------------------------------------------
	// 커널 영역 (Windows등의 핵심 코드가 실행중)

	// 유저 영역) 운영체제에서 제공하는 API(function) 호출
	// 커널 영역) 메모리를 할당해서 건내줌.
	// 유저 영역) ㄳㄳ 잘 쓸게~

	// 한 번에 많은 메모리를 할당하고, 그거를 쪼개서 사용한다.
	// [                                                          ]
	// C++에서는 기본적으로 CRT(C런타임 라이브러리)의 [힙 관리자]를 통해 힙 영역을 사용함
	// 단, 정말 원한다면, 우리가 직접 API를 통해 힙을 생성하고 관리할 수도 있다.(MMORPG 서버 메모리 풀링)

	void* ptr = malloc(sizeof(Monster));
	Monster* m1 = (Monster*)ptr;

	m1->_hp = 100;
	m1->_x = 0;
	m1->_y = 1;

	free(ptr);
	//얘는 몇 바이트 해제해야하는지 어떻게 알고 해제를 할까?
	//malloc으로 12byte(sizeof(Monster))를 할당해보면 아래와 같이 할당이 된다.
	//
	/*
	0x000002CF6ECB2650  0000000c  .... //12byte할당하겠다!
	0x000002CF6ECB2654  00000000  .... //뭔지모름1
	0x000002CF6ECB2658  00000097  ?... //뭔지모름2
	0x000002CF6ECB265C  fdfdfdfd  ???? //boundary
	0x000002CF6ECB2660  00000064  d... //할당영역1
	0x000002CF6ECB2664  00000000  .... //할당영역2
	0x000002CF6ECB2668  00000001  .... //할당영역3
	0x000002CF6ECB266C  fdfdfdfd  ???? //boundary
	*/
	//이렇게 header에 몇 바이트 할당했는지를 넣어놓기 때문에, free할 때는 몇 바이트 free해야하는지 따로 적어줄 필요가 없다.

	// Heap Overflow
	// - 유효한 힙 범위를 초과해서 사용하는 경우
	// 
	// free를 하지 않는다면?
	// - 당장은 별 문제 없이 실행이 된다.
	// - 하지만, 지속되는 프로그램에서 free가 없다면, 메모리 누수가 발생한다.
	// - 사용만하고, 반환은 하지 않다보니 나중에는 사용할 메모리가 부족해진다.
	// 
	// free를 여러번 한다면?
	// - double free
	// - 이건 그냥 crash만 나고 끝나는 경우가 대부분이다.
	// - 최초 free할 때 몇 바이트 할당했는지에 대한 힌트를 삭제함
	// - 두번 째 free를 하려면 몇 바이트 free해야하는지 모름. 
	// 
	// Use-After free
	// - free를 한 이후에 사용하려고 할 때
	// - 프로그래머 입장 : 망했다!
	// - 해커 입장 : 개이득!
	// - free이후에 null을 할당해주는 것이 안전하다.
	// - free(ptr);
	// - ptr = null;
	// 
	// - 
	// - 엉뚱한 메모리에 있는 값을 조작하게 될 수도있다.
	// - 크래시가 발생하면 그나마 다행이다.
	//
	m1->_hp = 100;

	//



	return 0;
}