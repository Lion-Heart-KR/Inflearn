//#include <iostream>
//#include <vector>
//using namespace std;
//
//int main()
//{
//	/// 배열, 벡터의 장단점
//	/// ****************중간 삽입 삭제(BAD)****************
//	/// 삽입 전 : [0] [1] [2] [3] [4] [5]
//	/// 삽입 후 : [0] [1] [10] [2] [3] [4] [5]
//	/// 이렇게 한 칸씩 뒤로 밀어줘야한다.
//	/// 밀어주기위해서는 복사해야하고, 복사비용이 많이 발생한다.
//	/// 삭제도 마찬가지
//	/// 삭제 전 : [0] [1] [2] [3] [4] [5]
//	/// 삭제 후 : [0] [1] [3] [4] [5]
//	/// 빈 칸을 둬서는 안된다. 그러기 위해서는 앞으로 한 칸씩 당겨줘야함. 이것도 복사.
//	/// 중간에 삽입/삭제시 복사비용이 많이 발생하는 것은 배열의 특성이다. 이런 부분에서 유용한건 리스트다.
//	/// 배열의 중간에 빈 칸이 있으면 안되는 이유는,, 사용의 편의를 위해서다. 
//	/// 여튼 벡터에서 중간에 삽입/삭제하는것은 상당히 비효율적이다.
//	/// 
//	/// ****************처음/끝 삽입/삭제****************
//	/// [1] 처음에 삽입 : 매우 비효율적. 벡터의 모든 데이터를 뒤로 한 칸씩 밀어줘야 한다. : push_back
//	/// [2] 끝에 삽입   : 한 번의 작업이면 충분하다. : 제공하지 않는다.
//	/// [3] 처음을 삭제 : 매우 비효율적. 벡터의 모든 데이터를 앞으로 한 칸씩 당겨줘야 한다. : pop_back
//	/// [4] 끝을 삭제   : 한 번의 작업이면 충분하다. : 제공하지 않는다.
//	/// 
//	/// ****************임의 접근(Random Access)****************
//	/// 1)i번 째의 데이터는 어디에 있는가? -> v[i]를 통해서 접근 가능
//	/// 2)3번 째 데이터는 어디에 있나? -> v[2]
//	/// 이런게 가능한 이유는, 배열의 중간에 빈 칸이 없는 덕분이다    
//	// 벡터 = 동적 배열 = 동적으로 커지는 배열
//	// 모든 원소가 하나의 메모리 블록에 연속하게 저장된다.
//
//	vector<int> v;
//	v.reserve(10);
//
//	for (vector<int>::size_type i = 0; i < v.capacity(); i++)
//		v.push_back(i);
//
//	//2번째 칸에 100이라는 값을 넣고싶다.
//	//2번째 칸부터는 한 칸씩 뒤로 밀어야 하기에 비효율적이다. 벡터의 크기가 커질수록 비효율적이다.
//	//insert의 반환값은, 값을 넣은 자리의 주소를 갖는 반복자(iterator)이다.
//	vector<int>::iterator it = v.insert(v.begin() + 1, 100);
//	cout << *(v.begin() + 1) << endl;
//	
//	//방금 넣은 것을 지우고싶다.
//	//반환값은 삭제한 자리의 주소값을 갖는 반복자이다.
//	v.erase(v.begin() + 1);
//	cout << *(v.begin() + 1) << endl;
//
//	//범위를 삭제
//	//범위의 끝은 삭제하지 않는다.
//	//아래처럼 하면, v[1]~v[4]를 삭제한다.
//	//반환값은 삭제한 범위의 첫 번째 주소. 아래의 경우에는 v.begin()+1
//	v.erase(v.begin() + 1, v.begin() + 5);
//
//	//벡터를 스캔하며, 특정 값이 존재한다면 일괄적으로 삭제하기
//
//	//벡터의 선언과 값을 할당
//	vector<int> v2;
//	srand(static_cast<unsigned int>(time(nullptr)));
//	for (int i = 0; i < 100; i++)
//		v2.push_back(rand() % 100);
//
//	//벡터의 숫자 3, 33을 삭제하기
//	cout << "before size : " << v2.size() << endl;
//	for (vector<int>::iterator it = v2.begin(); it != v2.end();)
//	{
//		int item = *it;
//		if (item == 3 || item == 33)
//		{
//			//iterator를 삭제할 경우, 자신의 정보까지 삭제해버려서 어떤 벡터의 iterator인지 알 수 없게 되버린다.
//			//따라서 삭제 후, 그 결과를 다시 it에 할당해준다.
//			it = v2.erase(it);
//		}
//		//만약 3이나 33을 찾아서 삭제한 경우, it는 3 혹은 33다음에 있던 값을 가리키는 상태가 된다.
//		//이 때 for문에서 자동으로 ++it를 해준다면, 해당 값은 검사하지 않고 넘어가게 되기 때문에
//		//3이나 33을 찾은 경우가 아닐때만 그 다음 값으로 넘어가도록 한다.
//		++it;
//	}
//
//	cout << "after size : " << v2.size() << endl;
//	
//	cout << v2.at(10) << endl;
//	v2.at(10) = 30;
//	cout << v2.at(10) << endl;
//
//
//	
//
//	return 0;
//}