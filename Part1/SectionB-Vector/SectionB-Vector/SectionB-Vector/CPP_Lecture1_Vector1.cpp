//#include <iostream>
//#include <vector>
//using namespace std;
//
///// <summary>
///// STL : Standard Template Library
///// -- 프로그래밍 할 때 필요한 자료구조/알고리즘들을 템플릿으로 제공하는 라이브러리
///// 
///// [1] 컨테이너
///// --- 데이터를 저장하는 객체(자료구조 : Data Structure)
///// 
///// [2] Vector(동적 배열)
///// --- Vector의 동작 원리(size/capacity)
///// --- 중간 삽입/삭제
///// --- 처음/끝 삽입/삭제
///// --- 임의 접근
///// 
///// </summary>
///// <returns></returns>
//
//int main()
//{
//    //배열
//    const int MAX_SIZE = 10;
//    int arr[MAX_SIZE] = {};
//
//    for (int i = 0; i < MAX_SIZE; i++)
//        arr[i] = i;
//    for (int i = 0; i < MAX_SIZE; i++)
//        cout << arr[i] << endl;
//
//    // ※배열의 문제점
//    // 1) 배열 크기를 유동적으로 변경하기 어렵다.
//    
//    cout << "-------------------여기서부터 Vector-------------------" << endl;
//
//    //동적배열
//    //어떻게 배열을 유동적으로 사용할 수 있게 된걸까?
//
//    // 1) 최초 메모리 할당시 여유분을 두고 메모리를 할당한다.
//    // 2) 여유분까지 꽉 찼으면, 메모리를 증설한다. 예를 들면
//    int* example = new int[100];
//    delete example;
//    example = new int[200];
//    // 궁금증
//    // [1] 여유분은 얼만큼이 적당한가
//    // [2] 증설할 때는 얼만큼이 적당한가
//    // [3] 기존의 데이터를 어떻게 처리할까
//    // [3]-1 : 기존의 데이터를 새로 할당받은 공간에 복사한다.(O)
//    // [3]-1-1 : 복사를 할 때 복사비용이 발생한다. 그렇기에, 추가공간을 너무 적게 잡으면, 복사를 자주해야하고 성능의 감소로 이어진다 - 시간 효율성
//    // [3]-1-2 : 하지만, 추가공간을 너무 크게 잡으면 공간 효율성이 감소한다. - 공간 효율성
//    // [3]-1-3 : capacity가 1.5배씩 늘어나다 보니까, 복사해야하는 데이터의 수가 많아질수록, capacity를 늘리는 작업의 빈도는 적어진다. 시간과 공간의 효율성을 적절히 맞춰주는것 같다
//    // 
//    // [3]-2 : 기존의 공간 바로 뒤에 이어서 공간을 할당받아서 이어쓴다. (X, 다른 데이터가 사용하고 있다.)
//    //
//
//    //Vector 선언
//    vector<int> v;
//
//    //선언시 벡터 크기 할당
//    vector<int> v2(1000, 1); //1000개 크기의 벡터, 초기값은 1
//    vector<int> v3 = v2;
//
//    //Vector에 값을 추가
//
//    //size : 실제 사용 데이터 개수
//    //capacity : 여유분을 포함한 용량 개수
//    //size가 capacity에 도달하면 capacity는 1.5배씩 증가한다(컴파일러마다 차이가 있다)
//    //대충 사용할 capacity를 안다면, 처음부터 할당해줄 수도 있다.
//    //면접단골 질문 : 왜 reserve를 사용하는가?
//    v.reserve(1000); //1000개를 넣을 공간을 잡아줭
//    //1000개를 초과하면 그대로 1.5배씩 증가
//    //또한 size가 작아진다고 해서 capacity 가 줄어들지는 않는다.
//
//    //유사하게 벡터의 사이즈도 지정해줄 수 있다.
//    //이 때 만약 capacity가 부족하면 자동으로 capa도 늘어난다
//    v.resize(1000);
//    //그리고 push_back을 통해서 vector에 데이터를 넣는 경우
//    //1001번째 데이터가 들어가는 것이기 때문에, size는 바로 1001로 증가하고 capa는 1500으로 증가한다.
//    //resize로 할당한 공간에 데이터를 넣기 위해서는 배열에 접근하듯이 접근해야한다.
//    
//    
//    for (int i = 0; i < 1000; i++)
//    {
//        //v.push_back(i);
//        v[i] = i;
//        cout << "(" << v.size() << ", " << v.capacity() << ") : " << &v[0] << endl;
//    }
//
//    //가장 마지막에 있는 데이터 꺼내기
//    v.pop_back();
//
//    //가장 마지막에 있는 데이터 보기
//    v.back();
//
//    //가장 앞에있는 데이터 보기
//    v.front();
//
//    //clear해줘도 capacity가 유지되는 것을 볼 수 있다.
//    v.clear();
//    cout << "(" << v.size() << ", " << v.capacity() << ") : "  << endl;
//
//    //capa를 줄이고 싶다면?
//    vector<int>().swap(v);
//    //깡통 벡터를 만들어서 v와 swap한다.
//    //v는 깡통벡터의 size, capa를 받아서 0, 0이 되는 반면
//    //v의 capa인 1000이 깡통 벡터에 들어가게 된다. 하지만, 깡통벡터는 해당 라인이 지난 후에는 소멸되어서 할당된 1000개 크기의 메모리도 바로 해제된다.
//
//    /*const int size = static_cast<const int>(v.size());
//    for (int i = 0; i < size; i++)
//        cout << v[i] << endl;*/
//
//    // 동적 배열
//    //
//
//    return 0;
//}